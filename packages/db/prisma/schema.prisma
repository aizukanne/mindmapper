generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==========================================
// User Management
// ==========================================

model User {
  id          String   @id @default(cuid())
  clerkId     String   @unique
  email       String   @unique
  name        String?
  avatarUrl   String?
  preferences Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  mindMaps            MindMap[]
  folders             Folder[]
  comments            Comment[]
  familyTrees         FamilyTree[]
  treeMembers         TreeMember[]
  sentInvitations     TreeInvitation[] @relation("SentInvitations")
  acceptedInvitations TreeInvitation[] @relation("AcceptedInvitations")
  uploadedPhotos      TreePhoto[]
  suggestionsMade     Suggestion[]     @relation("SuggestionsMade")
  suggestionsReviewed Suggestion[]     @relation("SuggestionsReviewed")
  uploadedDocuments   SourceDocument[] @relation("UploadedDocuments")
  reviewedDocuments   SourceDocument[] @relation("ReviewedDocuments")
  authoredStories     FamilyStory[]    @relation("AuthoredStories")
  storyComments       StoryComment[]   @relation("StoryComments")
  likedStories        StoryLike[]      @relation("LikedStories")
  mergesPerformed     PersonMerge[]    @relation("MergesPerformed")
  mergesReverted      PersonMerge[]    @relation("MergesReverted")
  activities          TreeActivity[]   @relation("ActivityActor")
  mapEvents           MapEvent[]
  templates           Template[]

  @@index([clerkId])
  @@index([email])
}

// ==========================================
// Organization
// ==========================================

model Folder {
  id        String   @id @default(cuid())
  name      String
  parentId  String?
  userId    String
  order     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  parent   Folder?   @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children Folder[]  @relation("FolderHierarchy")
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  mindMaps MindMap[]

  @@index([userId])
  @@index([parentId])
  @@index([userId, parentId, order])
}

// ==========================================
// Mind Map
// ==========================================

model MindMap {
  id           String                    @id @default(cuid())
  title        String
  description  String?
  thumbnail    String?
  isPublic     Boolean                   @default(false)
  isFavorite   Boolean                   @default(false)
  isArchived   Boolean                   @default(false)
  settings     Json                      @default("{}")
  userId       String
  folderId     String?
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  searchVector Unsupported("TSVECTOR")?

  // Relations
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder         Folder?         @relation(fields: [folderId], references: [id], onDelete: SetNull)
  nodes          Node[]
  connections    Connection[]
  events         MapEvent[]
  shares         Share[]
  comments       Comment[]
  shareableLinks ShareableLink[]

  @@index([userId])
  @@index([folderId])
  @@index([isPublic])
  @@index([isFavorite])
  @@index([createdAt])
  @@index([updatedAt])
}

// ==========================================
// Nodes
// ==========================================

enum NodeType {
  ROOT
  CHILD
  FLOATING
}

model Node {
  id           String                    @id @default(cuid())
  mindMapId    String
  parentId     String?
  type         NodeType                  @default(CHILD)
  text         String
  positionX    Float
  positionY    Float
  width        Float                     @default(150)
  height       Float                     @default(50)
  style        Json                      @default("{}")
  metadata     Json                      @default("{}")
  sortOrder    Int                       @default(0)
  isCollapsed  Boolean                   @default(false)
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  searchVector Unsupported("TSVECTOR")?

  // Relations
  mindMap  MindMap      @relation(fields: [mindMapId], references: [id], onDelete: Cascade)
  parent   Node?        @relation("NodeHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children Node[]       @relation("NodeHierarchy")
  outgoing Connection[] @relation("SourceNode")
  incoming Connection[] @relation("TargetNode")
  comments Comment[]

  @@index([mindMapId])
  @@index([parentId])
  @@index([mindMapId, parentId])
}

// ==========================================
// Connections
// ==========================================

enum ConnectionType {
  HIERARCHICAL
  CROSS_LINK
}

model Connection {
  id           String                    @id @default(cuid())
  mindMapId    String
  sourceNodeId String
  targetNodeId String
  type         ConnectionType            @default(HIERARCHICAL)
  label        String?
  style        Json                      @default("{}")
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  searchVector Unsupported("TSVECTOR")?

  // Relations
  mindMap    MindMap @relation(fields: [mindMapId], references: [id], onDelete: Cascade)
  sourceNode Node    @relation("SourceNode", fields: [sourceNodeId], references: [id], onDelete: Cascade)
  targetNode Node    @relation("TargetNode", fields: [targetNodeId], references: [id], onDelete: Cascade)

  @@unique([sourceNodeId, targetNodeId])
  @@index([mindMapId])
  @@index([sourceNodeId])
  @@index([targetNodeId])
}

// ==========================================
// Sharing
// ==========================================

enum Permission {
  OWNER
  EDITOR
  COMMENTER
  VIEWER
}

model Share {
  id         String     @id @default(cuid())
  mindMapId  String
  userId     String?
  shareToken String?    @unique
  permission Permission @default(VIEWER)
  password   String?
  expiresAt  DateTime?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  // Relations
  mindMap MindMap @relation(fields: [mindMapId], references: [id], onDelete: Cascade)

  @@index([mindMapId])
  @@index([userId])
  @@index([shareToken])
}

// Shareable Links - public URL sharing with optional password and expiration
model ShareableLink {
  id          String     @id @default(cuid())
  mindMapId   String
  token       String     @unique @default(cuid()) // Unique token for the shareable URL
  title       String?    // Optional custom title for the link
  permission  Permission @default(VIEWER)
  password    String?    // Optional password protection (hashed)
  expiresAt   DateTime?  // Optional expiration date
  maxAccess   Int?       // Optional maximum access count
  accessCount Int        @default(0) // Number of times the link has been accessed
  isActive    Boolean    @default(true) // Whether the link is currently active
  createdBy   String     // User who created the link
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relations
  mindMap MindMap @relation(fields: [mindMapId], references: [id], onDelete: Cascade)

  @@index([mindMapId])
  @@index([token])
  @@index([createdBy])
  @@index([isActive])
}

// ==========================================
// Comments
// ==========================================

model Comment {
  id           String                    @id @default(cuid())
  mindMapId    String
  nodeId       String?
  userId       String
  text         String
  resolved     Boolean                   @default(false)
  parentId     String?
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  searchVector Unsupported("TSVECTOR")?

  // Relations
  mindMap MindMap   @relation(fields: [mindMapId], references: [id], onDelete: Cascade)
  node    Node?     @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  user    User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent  Comment?  @relation("CommentThread", fields: [parentId], references: [id], onDelete: Cascade)
  replies Comment[] @relation("CommentThread")

  @@index([mindMapId])
  @@index([nodeId])
  @@index([userId])
  @@index([parentId])
}

// ==========================================
// Event History (Event Sourcing)
// ==========================================

enum MapEventType {
  CREATE_NODE
  UPDATE_NODE
  DELETE_NODE
  MOVE_NODE
  CREATE_CONNECTION
  UPDATE_CONNECTION
  DELETE_CONNECTION
  UPDATE_MAP
  RESTORE
}

enum MapEntityType {
  NODE
  CONNECTION
  MAP
}

model MapEvent {
  id            String        @id @default(cuid())
  mindMapId     String
  userId        String
  eventType     MapEventType
  entityType    MapEntityType
  entityId      String
  description   String? // Human-readable description of the change
  previousState Json? // State before the change (old values)
  newState      Json? // State after the change (new values)
  metadata      Json? // Additional context (IP, client info, etc.)
  createdAt     DateTime      @default(now())

  // Relations
  mindMap MindMap @relation(fields: [mindMapId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([mindMapId])
  @@index([userId])
  @@index([createdAt])
  @@index([mindMapId, createdAt])
  @@index([eventType])
  @@index([entityType])
  @@index([mindMapId, eventType])
  @@index([mindMapId, entityType])
}

// ==========================================
// Templates
// ==========================================

enum TemplateCategory {
  BUSINESS
  EDUCATION
  PERSONAL
  PROJECT_MANAGEMENT
  BRAINSTORMING
  STRATEGY
  MINDMAP
  FLOWCHART
  ORG_CHART
  OTHER
}

model Template {
  id          String           @id @default(cuid())
  name        String
  description String?
  thumbnail   String?
  category    TemplateCategory @default(OTHER)
  data        Json             // Stores complete template structure (nodes, connections, settings)
  isPublic    Boolean          @default(true)
  createdById String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  createdBy User? @relation(fields: [createdById], references: [id], onDelete: SetNull)

  @@index([category])
  @@index([isPublic])
  @@index([createdById])
  @@index([createdAt])
}

// ==========================================
// Family Tree
// ==========================================

enum TreePrivacy {
  PRIVATE
  FAMILY_ONLY
  PUBLIC
}

enum TreeRole {
  ADMIN
  MEMBER
  VIEWER
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum Gender {
  MALE
  FEMALE
  OTHER
  UNKNOWN
}

enum PersonPrivacy {
  PUBLIC
  FAMILY_ONLY
  PRIVATE
}

// DNA information privacy - defaults to most restrictive
enum DnaPrivacy {
  PRIVATE // Only person and tree admins can view
  FAMILY_ONLY // All tree members can view
}

enum PhotoPrivacy {
  PUBLIC
  ALL_FAMILY
  DIRECT_RELATIVES
  ADMINS_ONLY
  PRIVATE
  NONE
}

enum RelationshipType {
  PARENT
  CHILD
  SPOUSE
  SIBLING
  ADOPTIVE_PARENT
  ADOPTIVE_CHILD
  STEP_PARENT
  STEP_CHILD
  FOSTER_PARENT
  FOSTER_CHILD
  GUARDIAN
  WARD
}

enum DocumentType {
  BIRTH_CERTIFICATE
  DEATH_CERTIFICATE
  MARRIAGE_CERTIFICATE
  DIVORCE_DECREE
  CENSUS_RECORD
  MILITARY_RECORD
  IMMIGRATION_RECORD
  NEWSPAPER_ARTICLE
  PHOTO
  LETTER
  WILL
  DEED
  OTHER
}

model FamilyTree {
  id          String      @id @default(cuid())
  name        String
  description String?
  privacy     TreePrivacy @default(PRIVATE)
  createdBy   String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  creator       User             @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  members       TreeMember[]
  people        Person[]
  relationships Relationship[]
  marriages     Marriage[]
  invitations   TreeInvitation[]
  photos        TreePhoto[]
  documents     SourceDocument[]
  stories       FamilyStory[]
  suggestions   Suggestion[]
  merges        PersonMerge[]
  activities    TreeActivity[]

  @@index([createdBy])
  @@index([privacy])
  @@index([createdAt])
}

model TreeMember {
  id             String   @id @default(cuid())
  treeId         String
  userId         String
  role           TreeRole @default(VIEWER)
  linkedPersonId String?  @unique // The person in the tree that this user represents (for "Find Me")
  joinedAt       DateTime @default(now())

  // Relations
  tree         FamilyTree @relation(fields: [treeId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  linkedPerson Person?    @relation("LinkedTreeMember", fields: [linkedPersonId], references: [id], onDelete: SetNull)

  @@unique([treeId, userId])
  @@index([treeId])
  @@index([userId])
}

model Person {
  id           String                    @id @default(cuid())
  treeId       String
  firstName    String
  middleName   String?
  lastName     String
  maidenName   String?
  suffix       String?
  nickname     String?
  gender       Gender                    @default(UNKNOWN)
  birthDate    DateTime?
  birthPlace   String?
  deathDate    DateTime?
  deathPlace   String?
  isLiving     Boolean                   @default(true)
  biography    String?
  occupation   String?
  education    String?
  privacy      PersonPrivacy             @default(PUBLIC)
  profilePhoto String?
  positionX    Float?
  positionY    Float?
  generation   Int                       @default(0)

  // DNA Integration (placeholder - no actual DNA data stored)
  dnaTestProvider   String? // e.g., "23andMe", "AncestryDNA", "MyHeritage"
  dnaTestDate       DateTime? // When DNA test was taken
  yDnaHaplogroup    String? // Y-chromosome haplogroup (males only)
  mtDnaHaplogroup   String? // Mitochondrial haplogroup
  dnaKitNumber      String? // Optional kit number for reference
  dnaEthnicityNotes String? // Free-form notes about ethnicity results
  dnaMatchNotes     String? // Notes about DNA matches (no PII)
  dnaPrivacy        DnaPrivacy             @default(PRIVATE)

  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  searchVector Unsupported("TSVECTOR")?

  // Relations
  tree              FamilyTree       @relation(fields: [treeId], references: [id], onDelete: Cascade)
  relationshipsFrom Relationship[]   @relation("PersonFrom")
  relationshipsTo   Relationship[]   @relation("PersonTo")
  marriages         Marriage[]       @relation("MarriagePerson")
  photos            TreePhoto[]
  photoTags         PhotoTag[] // Photos this person is tagged in
  documents         SourceDocument[]
  documentLinks     DocumentPerson[] // Documents this person is linked to
  stories           FamilyStory[]
  storyLinks        StoryPerson[] // Stories this person is linked to
  linkedMember      TreeMember?      @relation("LinkedTreeMember")
  suggestions       Suggestion[]

  @@index([treeId])
  @@index([treeId, generation])
  @@index([lastName])
  @@index([privacy])
}

model Relationship {
  id               String           @id @default(cuid())
  treeId           String
  personFromId     String
  personToId       String
  relationshipType RelationshipType
  notes            String?
  birthOrder       Int? // For CHILD and SIBLING relationships, indicates birth order (1 = oldest)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  tree       FamilyTree @relation(fields: [treeId], references: [id], onDelete: Cascade)
  personFrom Person     @relation("PersonFrom", fields: [personFromId], references: [id], onDelete: Cascade)
  personTo   Person     @relation("PersonTo", fields: [personToId], references: [id], onDelete: Cascade)

  @@unique([personFromId, personToId, relationshipType])
  @@index([treeId])
  @@index([personFromId])
  @@index([personToId])
  // Optimized indexes for relationship computation queries
  @@index([treeId, personFromId, relationshipType])
  @@index([treeId, personToId, relationshipType])
  @@index([personFromId, personToId])
}

model Marriage {
  id            String    @id @default(cuid())
  treeId        String
  marriageDate  DateTime?
  marriagePlace String?
  divorceDate   DateTime?
  divorcePlace  String?
  notes         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  tree    FamilyTree @relation(fields: [treeId], references: [id], onDelete: Cascade)
  spouses Person[]   @relation("MarriagePerson")

  @@index([treeId])
}

model TreeInvitation {
  id         String           @id @default(cuid())
  treeId     String
  email      String
  role       TreeRole         @default(VIEWER)
  inviteCode String           @unique
  status     InvitationStatus @default(PENDING)
  expiresAt  DateTime?
  createdAt  DateTime         @default(now())
  acceptedAt DateTime?
  acceptedBy String?
  invitedBy  String

  // Relations
  tree     FamilyTree @relation(fields: [treeId], references: [id], onDelete: Cascade)
  inviter  User       @relation("SentInvitations", fields: [invitedBy], references: [id], onDelete: Cascade)
  acceptor User?      @relation("AcceptedInvitations", fields: [acceptedBy], references: [id], onDelete: SetNull)

  @@index([treeId])
  @@index([inviteCode])
  @@index([email])
  @@index([status])
}

model TreePhoto {
  id           String       @id @default(cuid())
  treeId       String
  personId     String? // Primary person (legacy, for backwards compatibility)
  url          String // Thumbnail or display URL
  originalUrl  String? // Full resolution original URL
  s3Key        String? // S3 key for original image
  thumbnailKey String? // S3 key for thumbnail
  width        Int? // Original image width in pixels
  height       Int? // Original image height in pixels
  fileSize     Int? // File size in bytes
  format       String? // Image format (jpeg, png, etc.)
  caption      String?
  dateTaken    DateTime?
  location     String?
  privacy      PhotoPrivacy @default(ALL_FAMILY)
  uploadedBy   String
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  // Relations
  tree         FamilyTree @relation(fields: [treeId], references: [id], onDelete: Cascade)
  person       Person?    @relation(fields: [personId], references: [id], onDelete: Cascade)
  uploader     User       @relation(fields: [uploadedBy], references: [id])
  taggedPeople PhotoTag[] // Multiple people can be tagged in a photo

  @@index([treeId])
  @@index([personId])
  @@index([uploadedBy])
  @@index([privacy])
  @@index([dateTaken])
}

// Join table for photo tagging (many-to-many)
model PhotoTag {
  id        String   @id @default(cuid())
  photoId   String
  personId  String
  createdAt DateTime @default(now())

  // Relations
  photo  TreePhoto @relation(fields: [photoId], references: [id], onDelete: Cascade)
  person Person    @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([photoId, personId])
  @@index([photoId])
  @@index([personId])
}

enum DocumentStatus {
  PENDING // Awaiting admin approval
  APPROVED // Approved as official record
  REJECTED // Rejected by admin
  DRAFT // Not yet submitted for approval
}

model SourceDocument {
  id             String                    @id @default(cuid())
  treeId         String
  personId       String?
  title          String
  description    String?
  documentType   DocumentType
  url            String? // Display/thumbnail URL
  originalUrl    String? // Full resolution URL
  s3Key          String? // S3 key for original file
  thumbnailKey   String? // S3 key for thumbnail/preview
  fileSize       Int? // File size in bytes
  mimeType       String? // File MIME type
  pageCount      Int? // Number of pages (for PDFs)
  ocrText        String? // Extracted text for search
  notes          String?
  citation       String? // Source citation
  dateOnDocument DateTime? // Date shown on document
  status         DocumentStatus            @default(DRAFT)
  isOfficial     Boolean                   @default(false) // Marked as official record
  hasWatermark   Boolean                   @default(false) // Apply watermark on download
  uploadedBy     String
  reviewedBy     String?
  reviewedAt     DateTime?
  reviewNote     String?
  createdAt      DateTime                  @default(now())
  updatedAt      DateTime                  @updatedAt
  searchVector   Unsupported("TSVECTOR")?

  // Relations
  tree          FamilyTree       @relation(fields: [treeId], references: [id], onDelete: Cascade)
  person        Person?          @relation(fields: [personId], references: [id], onDelete: Cascade)
  uploader      User             @relation("UploadedDocuments", fields: [uploadedBy], references: [id])
  reviewer      User?            @relation("ReviewedDocuments", fields: [reviewedBy], references: [id])
  linkedPersons DocumentPerson[] // Many-to-many for documents mentioning multiple people

  @@index([treeId])
  @@index([personId])
  @@index([documentType])
  @@index([status])
  @@index([uploadedBy])
}

// Join table for documents linked to multiple people
model DocumentPerson {
  id         String   @id @default(cuid())
  documentId String
  personId   String
  role       String? // e.g., "subject", "witness", "parent"
  createdAt  DateTime @default(now())

  document SourceDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  person   Person         @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([documentId, personId])
  @@index([documentId])
  @@index([personId])
}

enum StoryStatus {
  DRAFT // Not yet published
  PENDING // Awaiting approval (for living members)
  PUBLISHED // Approved and visible
  REJECTED // Rejected by admin
}

model FamilyStory {
  id           String                    @id @default(cuid())
  treeId       String
  personId     String? // Primary person (optional)
  authorId     String // User who wrote the story
  title        String
  content      String                    @db.Text // Rich text content (5000 char limit enforced in API)
  excerpt      String? // Short preview (auto-generated or manual)
  storyDate    DateTime? // When the story events occurred
  location     String? // Where the story takes place
  coverImage   String? // Optional cover image URL
  status       StoryStatus               @default(DRAFT)
  isPublic     Boolean                   @default(false) // Visible to non-tree members
  isFeatured   Boolean                   @default(false) // Featured on tree homepage
  viewCount    Int                       @default(0)
  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
  publishedAt  DateTime? // When story was published
  searchVector Unsupported("TSVECTOR")?

  // Relations
  tree          FamilyTree     @relation(fields: [treeId], references: [id], onDelete: Cascade)
  person        Person?        @relation(fields: [personId], references: [id], onDelete: SetNull)
  author        User           @relation("AuthoredStories", fields: [authorId], references: [id], onDelete: Cascade)
  linkedPersons StoryPerson[] // Many-to-many with persons
  comments      StoryComment[]
  likes         StoryLike[]

  @@index([treeId])
  @@index([personId])
  @@index([authorId])
  @@index([status])
  @@index([isPublic])
  @@index([isFeatured])
}

// Join table for linking stories to multiple people
model StoryPerson {
  id        String   @id @default(cuid())
  storyId   String
  personId  String
  role      String? // e.g., "subject", "narrator", "mentioned"
  createdAt DateTime @default(now())

  // Relations
  story  FamilyStory @relation(fields: [storyId], references: [id], onDelete: Cascade)
  person Person      @relation(fields: [personId], references: [id], onDelete: Cascade)

  @@unique([storyId, personId])
  @@index([storyId])
  @@index([personId])
}

// Comments on stories
model StoryComment {
  id        String   @id @default(cuid())
  storyId   String
  authorId  String
  content   String   @db.Text
  parentId  String? // For threaded replies
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  story   FamilyStory    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  author  User           @relation("StoryComments", fields: [authorId], references: [id], onDelete: Cascade)
  parent  StoryComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies StoryComment[] @relation("CommentReplies")

  @@index([storyId])
  @@index([authorId])
  @@index([parentId])
}

// Likes/favorites for stories
model StoryLike {
  id        String   @id @default(cuid())
  storyId   String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  story FamilyStory @relation(fields: [storyId], references: [id], onDelete: Cascade)
  user  User        @relation("LikedStories", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([storyId, userId])
  @@index([storyId])
  @@index([userId])
}

// ==========================================
// Suggested Edits
// ==========================================

enum SuggestionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SuggestionType {
  UPDATE_PERSON // Edit person details
  ADD_RELATIONSHIP // Add a relationship
  ADD_PERSON // Add a new person (e.g., parent)
  CORRECT_DATE // Date correction
  OTHER // Other suggestion
}

model Suggestion {
  id            String           @id @default(cuid())
  treeId        String
  personId      String // The person this suggestion is about
  suggesterId   String // User who made the suggestion
  type          SuggestionType
  status        SuggestionStatus @default(PENDING)
  title         String // Brief description
  description   String? // Detailed explanation
  currentData   Json? // Current values (for context)
  suggestedData Json // Proposed changes
  reviewerId    String? // Admin who reviewed
  reviewNote    String? // Admin's note on decision
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  reviewedAt    DateTime?

  // Relations
  tree      FamilyTree @relation(fields: [treeId], references: [id], onDelete: Cascade)
  person    Person     @relation(fields: [personId], references: [id], onDelete: Cascade)
  suggester User       @relation("SuggestionsMade", fields: [suggesterId], references: [id], onDelete: Cascade)
  reviewer  User?      @relation("SuggestionsReviewed", fields: [reviewerId], references: [id], onDelete: SetNull)

  @@index([treeId])
  @@index([personId])
  @@index([suggesterId])
  @@index([status])
  @@index([treeId, status])
}

// ==========================================
// Person Merge History (for undo capability)
// ==========================================

enum MergeStatus {
  COMPLETED // Merge is active
  REVERTED // Merge was undone
  EXPIRED // Past the 30-day undo window
}

model PersonMerge {
  id              String      @id @default(cuid())
  treeId          String
  primaryPersonId String // The person that remains after merge
  mergedPersonId  String // The person that was merged (deleted)
  performedById   String // User who performed the merge
  status          MergeStatus @default(COMPLETED)

  // Store complete backup data for undo
  mergedPersonData     Json // Full person record before deletion
  transferredRelations Json // Relationships that were transferred
  transferredMarriages Json // Marriages that were transferred
  transferredPhotos    Json // Photo IDs that were transferred
  transferredDocuments Json // Document IDs that were transferred
  transferredStories   Json // Story IDs that were transferred

  // Field selection (which fields came from which person)
  fieldSelections Json // { fieldName: 'primary' | 'merged' }

  // Metadata
  createdAt    DateTime  @default(now())
  expiresAt    DateTime // 30 days from creation
  revertedAt   DateTime?
  revertedById String?

  // Relations
  tree        FamilyTree @relation(fields: [treeId], references: [id], onDelete: Cascade)
  performedBy User       @relation("MergesPerformed", fields: [performedById], references: [id], onDelete: Cascade)
  revertedBy  User?      @relation("MergesReverted", fields: [revertedById], references: [id], onDelete: SetNull)

  @@index([treeId])
  @@index([primaryPersonId])
  @@index([mergedPersonId])
  @@index([status])
  @@index([expiresAt])
}

// ==========================================
// Activity Feed (US-FT-6.3)
// ==========================================

enum ActivityType {
  // Member activities
  MEMBER_JOINED // New member joined the tree
  MEMBER_LEFT // Member left or was removed
  MEMBER_ROLE_CHANGED // Member's role was changed

  // Person activities
  PERSON_ADDED // New person added to tree
  PERSON_UPDATED // Person details updated
  PERSON_DELETED // Person removed from tree
  PERSON_MERGED // Two persons were merged

  // Relationship activities
  RELATIONSHIP_ADDED // New relationship created
  RELATIONSHIP_REMOVED // Relationship removed
  MARRIAGE_ADDED // Marriage record added
  MARRIAGE_REMOVED // Marriage record removed

  // Content activities
  PHOTO_UPLOADED // New photo uploaded
  PHOTO_DELETED // Photo deleted
  DOCUMENT_UPLOADED // New document uploaded
  DOCUMENT_APPROVED // Document was approved
  DOCUMENT_REJECTED // Document was rejected
  STORY_PUBLISHED // Story was published
  STORY_UPDATED // Story was updated

  // Suggestion activities
  SUGGESTION_MADE // New suggestion submitted
  SUGGESTION_APPROVED // Suggestion was approved
  SUGGESTION_REJECTED // Suggestion was rejected

  // Tree activities
  TREE_UPDATED // Tree settings changed
  TREE_PRIVACY_CHANGED // Tree privacy setting changed
}

model TreeActivity {
  id      String       @id @default(cuid())
  treeId  String
  actorId String // User who performed the action
  type    ActivityType

  // Target references (nullable based on activity type)
  targetPersonId   String? // Person affected
  targetUserId     String? // User affected (for member events)
  targetPhotoId    String? // Photo affected
  targetDocumentId String? // Document affected
  targetStoryId    String? // Story affected

  // Activity details stored as JSON for flexibility
  metadata Json @default("{}") // Additional context (e.g., old/new values, names)

  // Privacy - some activities should be hidden from non-admins
  isPrivate Boolean @default(false)

  // Tracking
  createdAt DateTime @default(now())

  // Relations
  tree  FamilyTree @relation(fields: [treeId], references: [id], onDelete: Cascade)
  actor User       @relation("ActivityActor", fields: [actorId], references: [id], onDelete: Cascade)

  @@index([treeId, createdAt(sort: Desc)])
  @@index([treeId, type])
  @@index([actorId])
  @@index([targetPersonId])
  @@index([createdAt])
}

model ActivityReadStatus {
  id         String   @id @default(cuid())
  treeId     String
  userId     String
  lastSeenAt DateTime @default(now())

  @@unique([treeId, userId])
  @@index([userId])
}
